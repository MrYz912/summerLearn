# 1.let.const命令

## 作用域

- 全局作用域
- 函数作用域
- 块作用域
  - 一个{ }里为一个块作用域

## let和const用法

- let
  - 和var的作用相似，作用域为块作用域，不能重复定义
- const
  - 用来声明常量，声明时必须赋值，且不能修改，但声明为对象时可修改

# 2.解构赋值

就是一种特殊的赋值方法

## 数组解构赋值

 **= 的两边写数组**

- ...rest表示之后的数字形成一个数组，表示[3,4,5,6]

![1569656784261](assets/1569656784261.png)

- ,,之间表示一个元素，跟在后面的元素要相应推后

![1569657038221](assets/1569657038221.png)

- 前面两种还能结合来使用

![1569657181539](assets/1569657181539.png)

## 对象解构赋值

 **= 的两边写对象**

![1569657382458](assets/1569657382458.png)

# 3.正则扩展

## 组匹配

- 匹配网页标签

```javascript
var tagName = /<([^>]+)>[^<]*<\/1>/;

tagName.exec("<b>bold</b>")[1]
// 'b'
```

`<([^>]+)> `中匹配<>里除了>以外的所有字符

`[^<]*` 中匹配除了<以外的所有字符

后面的 `<\/1>` 表示对应的闭合标签

exec方法中的第二个元素返回的是 () 里匹配到的内容

## 修饰符

- y 修饰符

  - 和 g 修饰符的相同之处：都是全局匹配
  - 和 g 修饰符的不同之处：g 是从上次匹配位置往后任何一个位置有匹配上的都可以，而 y 要求的是从上次匹配位置往后的下一个位置就要匹配上。

- u 修饰符

  - 由于ES-5不支持四个字节的 UTF-16 编码，加上 u 修饰符后可以正确处理

    ```javascript
    /^\uD83D/u.test('\uD83D\uDC2A') // false
    /^\uD83D/.test('\uD83D\uDC2A') // true
    ```
    
  - 能正确识别码点大于`0xFFFF`的 Unicode 字符

































